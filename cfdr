##### Pairwise conditional FDR ##################################
#
# Computes conditional FDR for a set of pairs of p values. Estimates parameters of distribution of effect sizes for the conditional phenotype.
#
# Inputs
#  p_vals: an array of dimension n x 2; entry [i,1] is the p value for the ith SNP at the principal phenotype, [i,2] is the p value for the ith SNP at the jth phenotype.
#  n_cases_p: number of cases in study for principal phenotype
#  n_cases_c: number of cases in study for conditional phenotype
#  n_controls_p: number of controls in study for principal phenotype
#  n_controls_c: number of controls in study for conditional phenotype
#  control_overlap: number of controls shared between studies
#

cfdr = function(p_vals,n_cases_p,n_cases_c,n_controls_p,n_controls_c,control_overlap=0) {

N1=n_cases_p; N2=n_cases_c; N0=control_overlap; N01 = n_controls_p-N0; N02=n_controls_c-N0
rho = sqrt(1/( (1+(N02/N0))*(1+(N01/N0))*(1+(N01/N1)+(N0/N1))*(1+(N02/N2)+(N0/N2)) ));

w = which(!is.na(p_vals[,2]) & p_vals[,2]>0)
z = -qnorm(p_vals[w,2]/2);
z=z*sample(c(-1,1),length(w),replace=TRUE) # Randomly assign z values to be positive or negative.
f_n = fit.em(z,maxit=200)
pi0 = f_n$pars[1]
sigma = sqrt(f_n$pars[2])

cfdr_base(p_vals,rho,method=1,pi0j=pi0,sigmaj=sigma0)
}







##### Pairwise conditional FDR calculator #######################
#
# Computes conditional false discovery rate for a set of p value pairs from two GWAS, allowing for potential sharing of controls between the two studies. Does not estimate parameters for distribution of conditional effect sizes.
#
# Inputs
#  p_vals_ij: array of dimensions (# SNPs) x 2. Entry [i,1] is p value for principal phenotype for ith SNP; entry [i,2] is p value for conditional phenotype at ith SNP.
#  rho: expected correlation between z values
#  method: 1 to assume Zj has a mixed distribution characterised by pi0j, sigmaj; 2 to specify an empirical distribution. 
#  pi0j: relevant only if method == 1. Parameter for distribution of Zj. 
#  sigma: relevant only if method == 1. Parameter for distribution of Zj.
#  prior: relevant only if method == 2. Matrix with two rows; first is a list of potential values for Zj, second is a list of probabilities associated with those values.
# Outputs
#  f_i: f_i[i] = FDR(p_i|p_j)

cfdr_base = function(p_vals_ij,rho,method=1, pi0j = 1, sigmaj = 1, prior = rbind((1:10)/10,dnorm((1:10)/10,sd=3))) {

# Covariance between z values for i and j  
#N1=n_casesij[1]; N2=n_casesij[2]; N0=overlap; N01 = n_controlsij[1]-N0; N02=n_controlsij[2]-N0
#rho = sqrt(1/( (1+(N02/N0))*(1+(N01/N0))*(1+(N01/N1)+(N0/N1))*(1+(N02/N2)+(N0/N2)) ));

# Compute cutoff c_i
p_i = p_vals_ij[,1]; p_j = p_vals_ij[,2];
ord=order(p_i); cdf=(1:length(ord))/length(ord) # Quantiles of ordered list of p values
p_i = p_i[ord];
fdr1 = p_i/cdf;
c_i = p_i[min(which(fdr1>0.1))]

r1 = which(log(p_vals_ij[,1])+log(p_vals_ij[,2])<2*log(c_i)) # values not in triangle (p_i,p_j<1; -log10(p_i) + -log10(p_j) <-log10(c_i))
r2 = which(p_vals_ij[,1]<(10^-0.75)) # 
#r3 = which(p_vals_ij[,1]>(10^-12)) # SNPs with values lower than this 
r = intersect(r1,r2) # intersect(intersect(r1,r2),r3) # Values with ambiguous FDR

f_i = rep(0,dim(p_vals_ij)[1])
all = 1:length(f_i);
f_i[setdiff(all,r1)]=1; # approximately
f_i[setdiff(all,r2)]=1; # approximately
#f_i[setdiff(all,r3)]=0;

p_i = p_vals_ij[,1]; # Remaining points
p_j = p_vals_ij[,2];


# Compute empirical FDR at remaining points

cdf = rep(0,length(p_i))

oj = order(p_j)
p_i1 = p_i[oj]; p_j1 = p_j[oj] #
or = order(oj)[r] # index of snps in R in p_i1/p_j1

cr = rep(0,length(r))
for (i in 1:length(r)) {
 cdf[r[i]] = length(which(p_i1[1:or[i]]<=p_i1[or[i]]))/or[i]
}

# Equivalent technique

#for (i in 1:length(r)) {
# cdf[r[i]] = length(which(p_i<=p_i[r[i]] & p_j<=p_j[r[i]]))/length(which(p_j<=p_j[r[i]]))
#}




f_i[r]=exp_quantile(p_vals_ij[r,1],p_vals_ij[r,2],rho,method=method,pi0j=pi0j,sigmaj=sigmaj)/cdf[r] # Computation of FDR

return(f_i)
}


