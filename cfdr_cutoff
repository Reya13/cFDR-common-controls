#### cFDR cutoff ######################################
# 
# Computes the cutoff value for conditional FDR cFDR(p_i|p_j) corresponding to a given p value.
# Interpolates cFDR(x,y) to a grid. For some cutoff c, the area of L(c) is proportional to the number of points of the grid with cFDR<c. We set R(c) as the largest rectangle contained in L(c)] and aim to solve v(L(c)) c/v(R(c))=ucut for c, where v(X) is the expected number of null SNPs with (Pi,Pj) in X. If we assume that for c approximately equal to alpha, L(c)/R(c) is approximately equal to L(alpha)/R(alpha), then c = ucut * R(alpha)/L(alpha)
# 
#
# Inputs
#  p_valsij: list of p values for principal and conditional 
#   phenotypes; dimensions n_snps x 2
#  cfdr: conditional FDR for p_vals[,1]|p_vals[,2]
#  rho,pi0,sigma: parameters of the distribution of Pi x Pj
#  ucut: cutoff for unconditional FDR to consider significant;
#   default 5e-6
#  cfdr: if cond_FDR is already calculated, it may be entered here. If not, it is computed from p_valsij.
#
# Outputs
#  alpha: cutoff value for conditional FDR
#
#
compute_cutoff = function(p_vals, ,n_cases_p,n_cases_c,n_controls_p,n_controls_c,control_overlap=0, cfdr = rep(0,dim(p_valsij[1])), pcut = 5e-8) {

if (max(cfdr)==0) {
 cfdr = cfdr((p_vals,n_cases_p,n_cases_c,n_controls_p,n_controls_c,control_overlap)
 }

N1=n_cases_p; N2=n_cases_c; N0=control_overlap; N01 = n_controls_p-N0; N02=n_controls_c-N0
rho = sqrt(1/((1+(N02/N0))*(1+(N01/N0))*(1+(N01/N1)+(N0/N1))*(1+(N02/N2)+(N0/N2)) ));

w = which(!is.na(p_vals[,2])); wn = which(p_vals[w,1]>0.5); 
zi = sample(c(-1,1),length(wn),replace=TRUE)*qnorm(p_vals[w[wn],j]/2);
f_n = fit.em(zi,maxit=200)
pi0_null = f_n$pars[1]
sigma_null = sqrt(f_n$pars[2])

ufdr_cutoff = ucut(p_vals[,1],pcut)

ccut(p_vals,cfdr,rho,pi0_null,sigma_null,ufdr_cutoff)
}




#### cFDR cutoff calculator ######################################
# 
# Computes the cutoff value for conditional FDR cFDR(p_i|p_j) 
#  corresponding to p<5e-8.
# Interpolates cFDR(x,y) to a grid. For some cutoff c, the area of L(c) is proportional to the number of points of the grid with cFDR<c. We set R(c) as the largest rectangle contained in L(c)] and aim to solve v(L(c)) c/v(R(c))=ucut for c, where v(X) is the expected number of null SNPs with (Pi,Pj) in X. If we assume that for c approximately equal to alpha, L(c)/R(c) is approximately equal to L(alpha)/R(alpha), then c = ucut * R(alpha)/L(alpha)
# 
#
# Inputs
#  p_valsij: list of p values for principal and conditional 
#   phenotypes; dimensions n_snps x 2
#  cfdr: conditional FDR for p_vals[,1]|p_vals[,2]
#  rho,pi0,sigma: parameters of the distribution of Pi x Pj
#  ucut: cutoff for unconditional FDR to consider significant;
#   default 5e-6
#
# Outputs
#  alpha: cutoff value for conditional FDR
#

ccut = function(p_valsij,cfdr,rhoij,pi0_n,sigma_n,cutoff=5e-6) {
base = c2a(p_valsij,cfdr,cutoff,rhoij,pi0_n,sigma_n)
if (base<cutoff) {return(cutoff)} else {
cutoff1 = cutoff/(base/cutoff)

count = 1
while(abs(cutoff1-base)>(5e-8) & count<10) {
count = count + 1;
base = c2a(p_valsij,cfdr,cutoff1,rhoij,pi0_n,sigma_n)
cutoff1 = cutoff1/(base/cutoff)
}

return(cutoff1)
}
}



# Returns the value alpha at which the FDR is controlled if 
#  SNPs with cfdr<'cutoff' are deemed non-null.
#
# Used as a utility function to find the cutoff such that
#  FDR is controlled at a level equivalent to p<5e-8.
 
c2a=function(p_valsij,cfdr,cutoff,rhoij,pi0_n,sigma_n) {
w = which(!is.na(cfdr))
L = which(cfdr[w]<cutoff)
ufdr = p_valsij[w,1]*length(w)/rank(p_valsij[w,1]) 

ul = which.max(p_valsij[w[L],1]); lr = which.min(p_valsij[w[-L],1]);
left = -qnorm(p_valsij[w[L[ul]],1]/2); upper = -qnorm(p_valsij[w[L[ul]],2]/2)
right = -qnorm(p_valsij[w[-L][lr],1]/2)+1; lower = 0 #-qnorm(p_valsij[w[-L][lr],2]/2)

if (left >= right | length(L)<50 | max(p_valsij[w[which(ufdr<cutoff)],1])> max(p_valsij[which(cfdr<cutoff),1]) ) {
 return(cutoff)
} else {

# Values left,right,upper and lower bound the curved region of L. L also contains M* and the region V_3 bounded by
#  left<zi<right,zj>upper.



V_1 = (pi0_n*pmnorm(c(-left, -upper),mean = c(0,0),varcov = rbind(c(1,rhoij),c(rhoij,1)))) +
 ((1-pi0_n)*pmnorm(c(-left, -upper),mean = c(0,0),varcov = rbind(c(1,rhoij),c(rhoij,1+(sigma_n^2)))))
# integral over area bounded by minz<zi, a_z<zj; where a_z = z_j(which(zi=minz)
V_2 = (pi0_n*pmnorm(c(-right,-upper),mean = c(0,0),varcov = rbind(c(1,rhoij),c(rhoij,1)))) +
 ((1-pi0_n)*pmnorm(c(-right,-upper),mean = c(0,0),varcov = rbind(c(1,rhoij),c(rhoij,1+(sigma_n^2)))))
# integral over area bounded by maxz<zi, a_z<zj

V_3 = V_1 - V_2
# integral over area bounded by minp<zi<maxp; a_z<zj


V_4 = (pi0_n*pmnorm(c(-left, -upper),mean = c(0,0),varcov = rbind(c(1,-rhoij),c(-rhoij,1)))) +
 ((1-pi0_n)*pmnorm(c(-left, -upper),mean = c(0,0),varcov = rbind(c(1,-rhoij),c(-rhoij,1+(sigma_n^2)))))
# integral over area bounded by minz<zi, a_z<zj; where a_z = z_j(which(zi=minz)
V_5 = (pi0_n*pmnorm(c(-right,-upper),mean = c(0,0),varcov = rbind(c(1,-rhoij),c(-rhoij,1)))) +
 ((1-pi0_n)*pmnorm(c(-right,-upper),mean = c(0,0),varcov = rbind(c(1,-rhoij),c(-rhoij,1+(sigma_n^2)))))
# integral over area bounded by maxz<zi, a_z<zj

V_6 = V_4 - V_5
# integral over area bounded by -minp<-zi<-maxp; a_z<zj



xx = seq(left, right,length.out = 100); yy = seq(lower,upper,length.out = 100);
x0 = matrix(xx,length(xx),length(xx)); y0 = t(matrix(yy,length(yy),length(yy)))

# Messy numerical necessities and interpolation over region bounded by lower, upper, left and right
potential = which(p_valsij[w,1]<2.2*pnorm(-abs(left))) 
k = 20; pot_s= potential[(1:floor(length(potential)/k))*k] 

 zz = interp(c(-qnorm(p_valsij[w[potential],1]/2),-qnorm(p_valsij[w[pot_s],1]/2)),c(-qnorm(p_valsij[w[potential],2]/2),rep(0,length(pot_s))),c(cfdr[w[potential]],ufdr[pot_s]),xo = xx,yo=yy,duplicate="median") # Interpolation to cFDR values for a grid
# zz$z[i,j] is now the interpolated value of 

density_1 = ff(c(x0),c(y0),rhoij,pi0_n,sigma_n);
density_2 = ff(c(x0),c(y0),-rhoij,pi0_n,sigma_n);
int = (sum(density_1[which(zz$z<cutoff)]) + sum(density_2[which(zz$z<cutoff)]))*(upper-lower)*(right-left)/(length(xx)*length(yy))
# Integral over rectangle [left, right] x [lower,upper] of function zz.


if (max(zz$z[which(y0 <3)],na.rm=TRUE)>cutoff) {V_M = 2*pnorm(-max(x0[which(y0<3)][which(zz$z[which(y0<3)]>cutoff)]))} else {V_M=min(max(p_valsij[w[which(ufdr<cutoff)],1]),p_valsij[w[-L][lr],1])}
# integral over M

V_L = 2*int + 2*(V_3 + V_6) + 2*pnorm(-right)

c_r = approx(p_valsij[w,1], ufdr,V_M)$y # c_r is the cFDR of the upper right border of M*, equivalent to the UFDR at that point.

if (FALSE) {
plot(-qnorm(p_valsij[,1]/2),-qnorm(p_valsij[,2]/2),pch=".",xlim = c(0,10),ylim = c(0,10))
points(-qnorm(p_valsij[w[L],1]/2),-qnorm(p_valsij[w[L],2]/2),col="blue",cex= 0.3)
points(-qnorm(p_valsij[w[which(ufdr<cutoff)],1]/2),-qnorm(p_valsij[w[which(ufdr<cutoff)],2]/2),col="green",cex= 1)
points(-qnorm(p_valsij[w[L],1]/2),-qnorm(p_valsij[w[L],2]/2),col="blue",cex= 0.3)
lines(c(left, left,right,right),c(lower,upper,upper,lower),col="red");
wx = which(zz$z<cutoff); points(x0[wx],y0[wx],col="red",pch=".")
lines(c(-qnorm(2.5e-8),-qnorm(2.5e-8)),c(0,10),col="green")
lines(c(-qnorm(V_M/2),-qnorm(V_M/2)),c(0,10),col="gray")
}

return(V_L* c_r /V_M)

}
}






# Returns the pdf of z-values for SNPs which are null for phenotype i
#  at z_i,z_j.
ff = function(z_i,z_j,rho=0,pi0=0.9,sigma=3) {
(pi0*dmnorm(cbind(z_i,z_j),mean = c(0,0),varcov = rbind(c(1,rho),c(rho,1)))) +
 ((1-pi0)*dmnorm(cbind(z_i,z_j),mean = c(0,0),varcov = rbind(c(1,rho),c(rho,1+(sigma^2)))))
}







# Returns the pdf of p-values for SNPs which are null for phenotype i
#  at p_i,p_j.
pdf_p = function(p_i,p_j,rho=0,pi0=0.9,sigma=3) {
 (ff(-qnorm(p_i/2),-qnorm(p_j/2),rho,pi0,sigma) + 
 ff(qnorm(p_i/2),-qnorm(p_j/2),rho,pi0,sigma) + 
 ff(-qnorm(p_i/2),qnorm(p_j/2),rho,pi0,sigma) + 
 ff(qnorm(p_i/2),qnorm(p_j/2),rho,pi0,sigma)) *
 (pi/2)*exp(0.5*(qnorm(p_i/2)^2 + qnorm(p_j/2)^2))
 }






# uFDR cutoff computation 
# 
# Computes the cutoff value for unconditional FDR (p*N/rank(p)) 
#  corresponding to p<5e-8.
#
# Inputs
#  p_vals: list of p values
#  pcut: cutoff for p values; default 5e-8
#
# Outputs
#  alpha: cutoff value for unconditional FDR

ucut = function(p_vals,pcut = 5e-8) {
w = which(!is.na(p_vals))
k = length(which(p_vals<5e-8))
(5e-8)/((k+1)/length(w))
}
